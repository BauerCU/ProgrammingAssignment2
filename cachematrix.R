## Put comments here that give an overall description of what your
## functions do

## Write a short comment describing this function

### The function creates a list of three functions in relation to a matrix x:
#### 1: from the "matrix" slot, the matrix x can be retrieved
#### 2: the "write.inv" slot contains the function to write a value into the cache
#### 3: the "getfromcache" slot gives back that value

makeCacheMatrix <- function(x = matrix()) {
  x.inv <- NULL 
  x.return <- function() { x }
  calc.x.inv <- function(calc) { x.inv <<- calc }
  retrieve.x.inv <- function() { x.inv }
  return(list(matrix = x.return, 
              write.inv = calc.x.inv, getfromcache = retrieve.x.inv))
}

## Write a short comment describing this function

### This function first retrieves any value already in the cache, and returns it if is isn't NULL.
### Otherwise, the matrix is retrieved from the "matrix" slot of the function list generated by makeCacheMatrix.
### Then, the inverse of the matrix is calculated, and the value is written into the cache.

##### Note: makeCacheMatrix() needs to be called on the matrix of interest first, this should be assigned to a new variable. 
##### The cacheSolve() function is then executed on this new variable (see below for an example)
##### Upon the first execution, the inverse is calculated. In all subsequent execution, the value is retrieved from the cache.

cacheSolve <- function(x, ...) {
  x.inv <- x$getfromcache()
  if (is.null(x.inv) != T){
    print("This is the cached value")
    return(x.inv)
  }
  mat <- x$matrix()
  x.inv <- solve(mat, ...)
  x$write.inv(x.inv)
  print("This is the computed value")
  return(x.inv)
        ## Return a matrix that is the inverse of 'x'
}

### Example and functionality test
TM <- matrix(sample(1:500, 36), nrow = 6, ncol = 6) # create random test matrix
TM.mCM <- makeCacheMatrix(TM) # execute makeCacheMatrix() on test matrix
TM.i1 <- cacheSolve(TM.mCM) # execute cacheSolve
### repeat to see if caching worked:
TM.i2 <- cacheSolve(TM.mCM)

